package petadoption.api.recommendationEngine;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import petadoption.api.pet.Pet;
import petadoption.api.pet.criteria.FurColor;
import petadoption.api.pet.criteria.PetAttribute;
import petadoption.api.pet.criteria.Species;
import petadoption.api.pet.criteria.Temperament;
import petadoption.api.pet.criteria.breed.CatBreed;
import petadoption.api.pet.criteria.breed.DogBreed;
import petadoption.api.user.User;
import petadoption.api.userPreferences.Preference;
import petadoption.api.userPreferences.UserPreferences;

import java.util.*;
import java.util.stream.Collectors;

/**
 * @author Rafe Loya
 *
 * @see UserPreferences
 * @see Pet
 */
@Log4j2
public class RecommendationEngine {
    /**
     * Default value used to increment / decrement
     */
    public static final double DEFAULT_VAL = 0.001;

    /**
     * Default value for incrementing after attempting to adopt pet
     */
    public static final double DEFAULT_ADOPT_VAL = 0.050;

    /**
     * <code>Map.Entry</code> pair representing a pet and its total rating,
     * generated by <code>RecommendationEngine</code>.
     */
    @Getter
    @Setter
    private PriorityQueue<Map.Entry<Pet, Double>> recommendations;

    public RecommendationEngine() {
        recommendations = new PriorityQueue<>(new PetComparator());
    }

    /**
     * <code>toString()</code> method to print the following:
     * <ul>
     *     <li>pet's ranking</li>
     *     <li>pet's name</li>
     *     <li>pet's rating</li>
     * </ul>
     * for each <code>Pet</code> in the recommendation priority queue
     *
     * @return simple information about pets in recommendation
     */
    public String toStringSimple() {
        StringBuilder builder = new StringBuilder();
        SortedSet<Map.Entry<Pet, Double>> entries = new TreeSet<>(new PetComparator());
        int i = 1;

        entries.addAll(recommendations);

        for (Map.Entry<Pet, Double> entry : entries) {
            builder.append("[")
                    .append(i)
                    .append("] ")
                    .append(entry.getKey().getName())
                    .append(" : ")
                    .append(entry.getValue());
            ++i;
        }

        return builder.toString();
    }

    /**
     * <code>toString()</code> method to print the following:
     * <ul>
     *     <li>pet's ranking</li>
     *     <li>pet's id</li>
     *     <li>pet's name</li>
     *     <li>all of a pet's information (<code>toString()</code> of pet)</li>
     * </ul>
     * for each <code>Pet</code> in the recommendation priority queue
     *
     * @return detailed information about pets in recommendations
     */
    public String toStringDetailed() {
        StringBuilder builder = new StringBuilder();
        SortedSet<Map.Entry<Pet, Double>> entries = new TreeSet<>(new PetComparator());
        int i = 1;

        entries.addAll(recommendations);

        for (Map.Entry<Pet, Double> entry : entries) {
            builder.append(
                    "[" + i + "] "
                    + "[" + entry.getKey().getId() + "] : "
                    + entry.getKey().getName() + "\n"
                    + "========================================\n"
                    + entry.getKey()
                    + "========================================\n\n"
            );
            ++i;
        }

        return builder.toString();
    }

    /**
     * <code>toString()</code> method with two options:
     * <ul>
     *     <li>Simple : pet's ranking, name, and rating</li>
     *     <li>Detailed : pet's ranking, id, name, and all of
     *                    it's information
     *                    (<code>Pet</code>'s
     *                    <code>toString()</code> method)</li>
     * </ul>
     *
     * @param moreDetail whether to display simple or detailed information
     * @return recommended pets by their ranking
     */
    public String toString(boolean moreDetail) {
        if (!moreDetail) {
            return toStringSimple();
        } else {
            return toStringDetailed();
        }
    }

    /**
     * Logs the species that caused the error and
     * throws a new <code>RunTimeException</code>
     *
     * @param s <code>Species</code> that caused the error
     */
    /*
    private void unknownSpeciesError(Species s) throws RuntimeException {
        log.error("Unknown species encountered: {}", s);
        throw new RuntimeException("Unknown species encountered: " + s);
    }
    */

    /*
    public List<Pet> resortPetSample(UserPreferences up, List<Pet> pets) {
        SortedSet<Map.Entry<Pet, Double>> entries = new TreeSet<>(new PetComparator());

        for (Pet pet : pets) {
            entries.add(new AbstractMap.SimpleEntry<>(pet, calculatePetRating(up, pet)));
        }

        return entries.stream().map(Map.Entry::getKey).toList();
    }
     */

    /**
     * Determines <code>Breed</code> associated with the pet,
     * then iterates through each <code>Breed</code>,
     * summing the values of each associated rating.
     *
     * @param up <code>User</code>'s specific preferences
     * @param p  <code>Pet</code> to calculate ratings from
     * @return   sum of ratings associated with pet's breeds
     */
    /*
    public double calculateBreedRating(UserPreferences up, Pet p) {
        double rating = 0.0;

        switch(p.getSpecies()) {
            case CAT:
                for (CatBreed cb : p.getCatBreed()) {
                    rating += up.getCatBreedRating(cb);
                }
                break;
            case DOG:
                for (DogBreed db : p.getDogBreed()) {
                    rating += up.getDogBreedRating(db);
                }
                break;
            default:
                unknownSpeciesError(p.getSpecies());
        }

        return rating;
    }
    */

    /**
     * Iterates through <code>Pet</code>'s <code>FurColor</code>s,
     * summing the values of each associated rating.
     *
     * @param up <code>User</code>'s specific preferences
     * @param p  <code>Pet</code> to calculate ratings from
     * @return   sum of ratings associated with pet's fur colors
     */
    /*
    public double calculateFurColorRating(UserPreferences up, Pet p) {
        double rating = 0.0;

        for (FurColor fc : p.getFurColor()) {
            rating += up.getFurColorRating(fc);
        }

        return rating;
    }
    */

    /**
     * Iterates through <code>Pet</code>'s <code>Temperament</code>s,
     * summing the values of each associated rating.
     *
     * @param up <code>User</code>'s specific preferences
     * @param p  <code>Pet</code> to calculate ratings from
     * @return   sum of ratings associated with pet's temperaments
     */
    /*
    public double calculateTemperamentRating(UserPreferences up, Pet p) {
        double rating = 0.0;

        for (Temperament t : p.getTemperament()) {
            rating += up.getTemperamentRating(t);
        }

        return rating;
    }
    */

    public static double calculatePetRating(Map<PetAttribute, Double> prefs, Pet p) {
        double rating = 0.0;

        for (PetAttribute pa : p.getAttributes()) {
            if (prefs.containsKey(pa)) {
                rating += prefs.get(pa);
            }
        }

        return rating;
    }

    /**
     * Calculates a <code>Pet</code>'s total rating according to the
     * specified <code>User</code>'s preferences
     *
     * @param u User which will determine the pet's rating
     * @param p Pet to calculate the rating for
     * @return The given pet's rating according to the user's preferences
     */
    /*
    public double calculatePetRating(User u,Pet p) {
        double rating = 0.0;
        Map<PetAttribute, Double> preferences =
                u.getPreferences()
                        .stream().collect(
                                Collectors.toMap(
                                        x -> new PetAttribute(x.getType(), x.getAttribute()),
                                        Preference::getRating));

        // lambda map
        for (PetAttribute pa : p.getAttributes()) {
            if (preferences.containsKey(pa)) {
                rating += preferences.get(pa);
            }
        }

        return rating;
    }
    */

    /**
     * Calculates a <code>Pet</code>'s total rating through
     * the members in <Code>UserPreferences</Code>, which map to
     * the specific criterion's rating.
     *
     * @param u <code>User</code>'s specific preferences
     * @param p  <code>Pet</code> to calculate ratings from
     * @return   given pet's total rating
     */
    /*
    public double calculatePetRating(UserPreferences up, Pet p) {
        double totalRating = 0.0;

        totalRating += up.getSpeciesRating(p.getSpecies());               // Species
        totalRating += calculateBreedRating(up, p);                       // Breed
        totalRating += up.getSizeRating(p.getPetSize());                  // Size
        totalRating += calculateFurColorRating(up, p);                    // Fur Color
        totalRating += up.getFurTypeRating(p.getFurType());               // Fur Type
        totalRating += up.getCoatLengthRating(p.getCoatLength());         // Coat Length
        totalRating += up.getAgeRating(p.getAge());                       // Age
        totalRating += calculateTemperamentRating(up, p);                 // Temperament
        totalRating += up.getHealthRating(p.getHealthStatus());           // Health
        totalRating += up.getSpayedNeuteredRating(p.getSpayedNeutered()); // Spayed / Neutered
        totalRating += up.getSexRating(p.getSex());                       // Sex

        return totalRating;
    }
    */

    public static void updatePreferences(User u, Pet p, double updateVal) {
        for (PetAttribute pa : p.getAttributes()) {
            if (u.getPreferences().containsKey(pa)) {
                u.getPreferences().put(pa, u.getPreferences().get(pa) + updateVal);
            }
        }
    }

    /*
    public void updatePreferences(User u, Pet p, double updateVal) {
        Map<PetAttribute, Double> preferences =
                u.getPreferences()
                        .stream().collect(
                                Collectors.toMap(
                                        x -> new PetAttribute(x.getType(), x.getAttribute()),
                                        Preference::getRating));

        for (PetAttribute pa : p.getAttributes()) {
            if (preferences.containsKey(pa)) {
                preferences.put(pa, preferences.get(pa) + updateVal);
            }
        }

        HashSet<Preference> newPreferences = new HashSet<>();
        for (Map.Entry<PetAttribute, Double> entry : preferences.entrySet()) {
            newPreferences.add(new Preference(entry.getKey().getType(), entry.getKey().getAttribute(), entry.getValue()));
        }

        u.setPreferences(newPreferences);
    }
     */

    /**
     * Changes a given <code>User</code>'s <code>UserPreferences</code>
     * according to a passed <code>double</code>.
     * <p>
     * This function is intended to be a helper function for
     * <code>ratePet()</code></code> and <code>rateAdoptedPet()</code>,
     * but can be called directly for custom increment / decrement values.
     *
     * @param up        <code>User</code>'s specific preferences
     * @param p         <code>Pet</code> to reference criteria from
     * @param updateVal value to increment / decrement critera ratings by
     */
    /*
    public void updatePreferences(UserPreferences up, Pet p, double updateVal) {
        //double updateVal = like ? DEFAULT_VAL : -(DEFAULT_VAL);

        // Species
        up.updateSpeciesRating(p.getSpecies(), updateVal);

        // Breed
        switch(p.getSpecies()) {
            case CAT:
                for (CatBreed cb : p.getCatBreed()) {
                    up.updateCatBreedRating(cb, updateVal);
                }
                break;
            case DOG:
                for (DogBreed db : p.getDogBreed()) {
                    up.updateDogBreedRating(db, updateVal);
                }
                break;
            default:
                unknownSpeciesError(p.getSpecies());
        }

        // Size
        up.updateSizeRating(p.getPetSize(), updateVal);

        // Fur Color
        for (FurColor fc : p.getFurColor()) {
            up.updateFurColorRating(fc, updateVal);
        }

        // Fur Type
        up.updateFurTypeRating(p.getFurType(), updateVal);

        // Coat Length
        up.updateCoatLengthRating(p.getCoatLength(), updateVal);

        // Age
        up.updateAgeRating(p.getAge(), updateVal);

        // Temperament
        for (Temperament t : p.getTemperament()) {
            up.updateTemperamentRating(t, updateVal);
        }

        // Health
        up.updateHealthRating(p.getHealthStatus(), updateVal);

        // Spayed / Neutered
        up.updateSpayedNeuteredRating(p.getSpayedNeutered(), updateVal);

        // Sex
        up.updateSexRating(p.getSex(), updateVal);
    }
    */

    public static void ratePet(User u, Pet p, boolean like) {
        double updateVal;

        if (like) updateVal = DEFAULT_VAL;
        else updateVal = -(DEFAULT_VAL);

        updatePreferences(u, p, updateVal);
    }

    /**
     * Increments / decrements the ratings in the given <code>UserPreferences</code>
     * mapped by the criteria contained in a passed <code>Pet</code> instance.
     *
     * @param up   <code>User</code>'s specific preferences
     * @param p    <code>Pet</code> to reference criteria from
     * @param like if the <code>User</code> liked the pet
     */
    /*
    public void ratePet(UserPreferences up, Pet p, boolean like) {
       // double updateVal = like ? DEFAULT_VAL : -(DEFAULT_VAL);
        double updateVal;

        if (like) {
            updateVal = DEFAULT_VAL;
        } else {
            updateVal = -(DEFAULT_VAL);
        }


        updatePreferences(up, p, updateVal);
    }
    */

    /**
     * Increments the ratings in the given <code>UserPreferences</code>
     * mapped by the criteria contained in a passed <code>Pet</code>
     * instance. The amount that the criteria ratings will be incremented by
     * is significantly larger than <code>ratePet()</code>.
     * <p/>
     * This function is intended to be used when a <code>User</code>
     * contacts the <code>AdoptionCenter</code> associated with the given
     * <code>Pet</code>.
     *
     * @param u <code>User</code>'s specific preferences
     * @param p  <code>Pet</code> to reference criteria from
     */
    public static void rateAdoptedPet(User u, Pet p) {
        updatePreferences(u, p, DEFAULT_ADOPT_VAL);
    }
}